
1. Implementation of Boyer-Moore
   While implementing the Boyer-Moore code, I first examined YouTube resources to understand the core logic. Then, we wrote the function using Gemini. Initially, to make it a complete Boyer-Moore implementation, we added both the Bad Character and Good Suffix heuristics. However, since the Good Suffix rule did not work efficiently, we removed it, leaving only the Bad Character logic. Additionally, for Unicode values (outside the standard 256 ASCII), we scan characters one by one. Although this slows down the code, I decided it was better than the code crashing. Logically, Moore scans the text and pattern from back to front; if a mismatch occurs, it jumps to the previous occurrence of that character in the pattern, allowing for rapid reading. In most tests, the Naive algorithm proved faster. The reason for this is that the text in the test cases is very short, and the array creation step required for my Boyer-Moore implementation significantly increases the duration relative to the search time.

2. GoCrazy (Hybrid Algorithm)
   In the GoCrazy algorithm, I combined KMP and Boyer-Moore. Since Moore is already excellent at skipping (jumping), I hybridized it with KMP to further speed it up. While Moore jumps rapidly, KMP catches potential matching patterns that might be missed, making the code both faster and safer. I wrote this code generally with support from Gemini. This code is also safeguarded against Unicode issues. However, similar to Boyer-Moore, it remained slower than the Naive algorithm in these specific test cases because the inputs were too short to overcome the initialization overhead.

3. PreAnalysis Strategy
   In PreAnalysis, I found it logical to use Naive for short test cases because it avoids the overhead of creating arrays and the complexity of logic like Karp or KMP. I decided to use KMP if the pattern contained many repetitive segments, as Boyer-Moore can slow down in such cases, and it is also problematic for Rabin-Karp. I chose to use Rabin-Karp when both the text and pattern are long and contain distinct characters; finding matches by sliding via hash codes is simpler in this scenario, saving KMP from searching through complex patterns and saving Moore from the difficulty of calculating jumps. I implemented Boyer-Moore as the default for general cases since it works fast in most standard scenarios. I wrote this code with Gemini as well; I established the logic and architecture, and it wrote the code under my supervision.

4. Performance & Challenges
   Overall, my Boyer-Moore and GoCrazy codes take slightly longer than Naive due to the setup operations (overhead) during the creation phase, which caused them to remain slower in most cases. I tried very hard to solve this optimization issue, but I could only take it so far; unfortunately, Naive still runs faster in many situations. Although my PreAnalysis code should theoretically work well according to my logic, it remained slow in most scenarios. Since I couldn't devise a different logic, I left it at that state. I believe this stems from the fact that the test cases are extremely short.

5. Conclusion & Experience
   My general experience with this assignment involved writing the codes with Gemini, where I tried to integrate my own logic into its output. Gemini challenged me significantly while trying to make Boyer-Moore and GoCrazy work for shorter test cases and Unicode characters, but I managed to overcome these issues. I learned a more efficient version of Moore thanks to the GoCrazy implementation. Furthermore, I learned the strengths and weaknesses of different algorithms against each other. Overall, it was a very productive assignment for me. I eventually gave up on the PreAnalysis part as the results were slightly underwhelming and I couldn't think of a better method. However, I am satisfied with what I have accomplished.

6. AI Chat Log
   You can find my research and debugging process with the LLM here: https://gemini.google.com/share/b391e6299bfa